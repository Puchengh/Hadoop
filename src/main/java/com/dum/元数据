1历史日志文件：编辑完成的日志文件
       日志文件：记录客户端对元数据操作的日志  只记录操作信息
       比如 某一个用户对某一个目录执行某一种操作
2正在编辑的日志文件  目前对元数据修改的操作记录的文件
3镜像文件 就是真实的数据   元数据的内容：抽象目录树  数据和快的映射  数据块的储存节点
        是真实的元数据信息经过序列化之后的文件  在集群启动的时候回加载这个文件   加载的时候回进行一个反序列化
        fsimage_0000000000000000057.md5  序列化之后加密的文件
4合并点记录文件  seen_txid   记录的是下一次需要合并的日志文件的起始偏移量

 在hdfs格式化的时候
    fsimage_0000000000000000057   格式化的镜像文件
    fsimage_0000000000000000057.md5
    seen_txid  合并点
    当集群第一次启动的时候回生成一个正在编辑的日志文件
    edits_inprogress_0000000000000000060

真实的硬盘上的存储的完整的元数据：

        secondaryNameNode的作用是  帮助nameNode完成元数据的整合
        镜像文件和正在编辑的日志文件
        fsimage_0000000000000000057+edits_inprogress_0000000000000000060

        如果fsimage不和日志文件进行合并，fsimage和内存元数据差别越来越大
        namenode的本身主要职责是保存元数据处理客户端的请求  本身压力比较大
        所以这个事情是sercondaryNamenode去做这件事情
        触发合并的条件
            触发合并的条件：两个触发条件是或者的关系都会触发checkpoint的过程
                1  时间节点  时间间隔3600=1h
                2  元数据的条数  1000000  数据调试100W条的时候也会触发
        无论什么时候内存中永远是最新的最完整的元数据

        secondaryNameNode进行checkpoint过程后自己也会保留一份fsimage.point问价
        原因是为namenode做备份，以防naemnode宕机之后丢失元数据的时候进行帮助namenode恢复
        如果不是第一次进行checkpoint的时候  secondarynamenode只需要去拉去合并记录点之后的入职文件就可以了

        在没有达到checkpoint过程的这段时间集群正常关闭了，在集群关闭之后内存中的元数据会固话写入到磁盘中一份
        关闭集群的时候保证磁盘上的元数据和内存中的一致
